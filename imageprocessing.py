# -*- coding: utf-8 -*-
"""ImageProcessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sZK5wgIeLgjzk7UKeZ7HYpBV3xrOnBzp
"""

from google.colab import drive
drive.mount('/content/gdrive' )

train_x_path = '/content/gdrive/My Drive/COMP4900A3-VeeNick/feed_file/Train.pkl'
train_label_path = '/content/gdrive/My Drive/COMP4900A3-VeeNick/feed_file/TrainLabels.csv'
test_x_path = '/content/gdrive/My Drive/COMP4900A3-VeeNick/feed_file/Test.pkl'
test_label_path = '/content/gdrive/My Drive/COMP4900A3-VeeNick/feed_file/y_holder.csv'
#keep this so we can label the graph
class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

import imp
imp.load_source("loader",'/content/gdrive/My Drive/COMP4900A3-VeeNick/load_data.py')
import loader
import pickle 
import numpy as np
import matplotlib.pyplot as plt
import random 
from google.colab.patches import cv2_imshow
import cv2

data = pickle.load( open( train_x_path, 'rb' ), encoding='bytes')
targets = np.genfromtxt(train_label_path, delimiter=',')

r1 = random.randint(0, 60000) 
tester = data[53389,:,:]
plt.imshow(tester,cmap='gray', vmin=0, vmax=256)
cv2.imwrite('img_raw.jpg',tester , [int(cv2.IMWRITE_JPEG_QUALITY), 90])

def preproc_img_again(image,min_val,max_val):
  original = image.copy()
  blurred = cv2.GaussianBlur(image, (3, 3), 0)
  # canny = cv2.Canny(blurred, 120, 255, 1)
  canny = cv2.Canny(blurred, min_val, max_val, 1)
  kernel = np.ones((5,5),np.uint8)
  dilate = cv2.dilate(canny, kernel, iterations=1)

# Find contours
  cnts = cv2.findContours(dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  cnts = cnts[0] if len(cnts) == 2 else cnts[1]

# Iterate thorugh contours and filter for ROI
  image_number = 0
  result = []
  for c in cnts:
    x,y,w,h = cv2.boundingRect(c)
    cv2.rectangle(image, (x, y), (x + w, y + h), (36,255,12), 2)
    ROI = original[y:y+h, x:x+w]
    # cv2.imwrite("ROI_{}.png".format(image_number), ROI)
    image_number += 1
    proc_ROI = cv2.resize(ROI,(30,30),interpolation = cv2.INTER_CUBIC)
    result.append(proc_ROI)

  return image_number,result

def find_next_loc(img,kernel_size,min_val,max_val):
  blurred = cv2.blur(img,kernel_size)
  canny = cv2.Canny(blurred, min_val, max_val)
  # cv2_imshow(canny)

  pts = np.argwhere(canny==0)
  y1,x1 = pts.min(axis=0)
  return y1,x1

def find_next(img):
  start_y_proc,end_y_proc,max_col_proc = return_max_length_horizontal(img,10)
  start_x_proc,end_x_proc,max_row_proc = return_max_length_horizontal(np.transpose(img),10)
  return start_y_proc,end_y_proc,start_x_proc,end_x_proc


def return_max_distance_1Drow(arr_in,tolerance):
  end = 0
  start = 0
  arr = list(arr_in)
  def return_start(l):
    try:
      indexPos = l.index(255)
      return indexPos
    except ValueError as e:
      return 0  
  # print(type(arr))
  col_num = len(arr)
  
  rev_temp = arr[::-1]
  # print(arr)
  # print(rev_temp)
  start_ind = return_start(arr)
  # print("Start at",start_ind)
  end_ind = col_num - return_start(rev_temp)
  # print("End at",end_ind)

  result = end_ind - start_ind

  if (result == col_num):
    return 0
  else:
    return result

def longest(numbers,tolerance):
  max, count_ = 1, 1
  start_idx, end_idx = 0, 0
  for i in range(len(numbers)-1):
        # if difference between number and his follower is 1,they are in sequence
    if numbers[i+1]-numbers[i] > tolerance:
      count_ = count_+1
    else:
      if count_ > max :
        max = count_
        end_idx = i
        start_idx = i+1 - max
            # Reset counter
        count_ = 1
  return (start_idx,end_idx,max)



# print(longest([1, 3, 11,  12,  14,  18,  56, 3, 4, 6],3))

def return_max_length_horizontal(arr2D,tol):
  blur = cv2.GaussianBlur(arr2D,(3,3),0)
  ret3,thresh_gray = cv2.threshold(blur,50,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
  row = arr2D.shape[0]
  col = arr2D.shape[1]

  list_length = []
  list_index = []


  for r in range(row):
    list_length.append(return_max_distance_1Drow(thresh_gray[r],tol))
  
  start_ind = next((i for i, x in enumerate(list_length) if x),None)
  end_ind = next((i for i, x in enumerate(list_length[::-1]) if x),None)

  if (start_ind == None or end_ind == None):
    return 0,0,0
  else:
    end_ind_arr = row - end_ind
   
  return start_ind,end_ind_arr,max(list_length)


def my_testing_function(img,kernel_size,min_val,max_val,process_shape):
  result = []
  tmp_ = np.copy(img)
  print('Show orginial')
  cv2_imshow(tmp_)

  start_y_proc,end_y_proc,max_col_proc = return_max_length_horizontal(tmp_,10)
  start_x_proc,end_x_proc,max_row_proc = return_max_length_horizontal(np.transpose(tmp_),10)
  tmp = tmp_[start_y_proc:end_y_proc,start_x_proc:end_x_proc]

  for i in range(3):
    # print("At loop",i)
    # cv2_imshow(tmp)
    blurred = cv2.blur(tmp,kernel_size)
    canny = cv2.Canny(blurred, min_val, max_val)

    pts = np.argwhere(canny==0)
    y1,x1 = pts.min(axis=0)

    # cv2_imshow(canny)
    if (i == 2):
      proc_area = tmp[:,x1:]
    else:
      proc_area = tmp[:,x1:x1+30]
    # cv2_imshow(proc_area)

    start_y,end_y,max_col = return_max_length_horizontal(proc_area,10)
    start_x,end_x,max_row = return_max_length_horizontal(np.transpose(proc_area),10)
   
    if start_x == 0 and start_y == 0 and i == 2:
      cropped = tmp[:28,:]
      # print(cropped)
    else:
      cropped = tmp[start_y:end_y,(x1):x1+max_col]
    # cv2_imshow(cropped)
    # print(cropped.shape)
    if cropped.shape[0] > 50 or cropped.shape[1] > 70:
      start_y_t,end_y_t,start_x_t,end_x_t=find_next(cropped)
      cropped = cropped[start_y_t:start_y_t+28,start_x_t:end_x_t]
      # print('Proc cropped again')
      # print(cropped.shape)
      # cv2_imshow(cropped)
  

    my_cropped = cv2.resize(cropped,process_shape,interpolation = cv2.INTER_CUBIC)
    result.append(my_cropped)
    # print("Cropped",i)
    # cv2_imshow(cropped)

    if (i < 2):
      tmp = tmp[:,x1+max_col+5:]
      next_y,endynah,next_x,endxnah = find_next(tmp)
      tmp = tmp[:,next_x:]
      # print("Keep cropping this")
      # cv2_imshow(tmp)

  add_together = np.concatenate((result[0],result[1],result[2]),axis=1)
  cv2_imshow(add_together)
  return add_together

# https://stackoverflow.com/questions/56604151/python-extract-multiple-objects-from-image-opencv
import cv2
import numpy as np


def proc_img(image,min_val,max_val):
  original = image.copy()

  blurred = cv2.GaussianBlur(image, (3, 3), 0)
  # canny = cv2.Canny(blurred, 120, 255, 1)
  canny = cv2.Canny(blurred, min_val, max_val, 1)
  kernel = np.ones((5,5),np.uint8)
  dilate = cv2.dilate(canny, kernel, iterations=1)

# Find contours
  cnts = cv2.findContours(dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  cnts = cnts[0] if len(cnts) == 2 else cnts[1]

# Iterate thorugh contours and filter for ROI
  # image_number = 0
  result = []
  raw_result = []
  for c in cnts:
    x,y,w,h = cv2.boundingRect(c)
    cv2.rectangle(image, (x, y), (x + w, y + h), (36,255,12), 2)
    ROI = original[y:y+h, x:x+w]
    proc_ROI = cv2.resize(ROI,(30,30),interpolation = cv2.INTER_CUBIC)
    # cv2_imshow(ROI)
    result.append(proc_ROI)
    # print(ROI.shape)
    raw_result.append(ROI)
  # cv2.waitKey(0)

  if (len(result) == 3):
    add_together = np.concatenate((result[0],result[1],result[2]),axis=1)
    return add_together
  else:
    return my_testing_function(original,(3,3),50,250,(30,30))
    
  
  # cv2_imshow(add_together)

  
  # return add_together

type(data) #data[10315,:,:]

r1 = random.randint(0, 60000) 
test = data[r1,:,:]

cv2_imshow(proc_img(test,120,255))
plt.imshow(test,cmap='gray', vmin=0, vmax=256)

# cv2.imwrite(test,'original.jpg')
out = proc_img(test,120,255)
# cv2.imwrite(proc_img(test,120,255),'processed_image.jpg')

cv2.imwrite('img_proc.jpg',out , [int(cv2.IMWRITE_JPEG_QUALITY), 90])

newData = []

for i in range(60000):
  print("We are at",i)
  newData.append(proc_img(data[i,:,:],120,155))
    
nD = np.array(newData)

optimized_path_train = '/content/gdrive/My Drive/COMP4900A3-VeeNick/feed_file/optimized_train_Vee.pkl'

with open(optimized_path_train, 'wb') as f:
    pickle.dump(nD, f)

test_data = pickle.load( open( test_x_path, 'rb' ), encoding='bytes')

test_newData = []

for i in range(10000):
  print("We are at",i)
  test_newData.append(proc_img(test_data[i,:,:],120,155))
    
nD_test = np.array(test_newData)

optimized_test_train = '/content/gdrive/My Drive/COMP4900A3-VeeNick/feed_file/optimized_test_Vee.pkl'

with open(optimized_test_train, 'wb') as f:
    pickle.dump(nD_test, f)